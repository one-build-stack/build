name: Build

on:
  workflow_dispatch:
    inputs:
      runs_on:
        required: false
        default: 'ubuntu-latest'
      repo_owner:
        required: true
      repo_name:
        required: true
      branch:
        required: true
        default: 'main'
      commands:
        required: true
        default: 'bun run build'
      output_paths:
        required: true
        default: 'dist'
      env_vars:
        required: false
      callback_url:
        required: false
        default: ''

permissions:
  contents: read
  actions: read

env:
  SALT: ${{ secrets.SALT }}
  GITLAB_URL: ${{ secrets.GITLAB_URL }}
  GITLAB_USERNAME: ${{ secrets.GITLAB_USERNAME }}
  GITLAB_PASSWORD: ${{ secrets.GITLAB_PASSWORD }}

jobs:
  build:
    runs-on: ${{ inputs.runs_on || 'ubuntu-latest' }}

    steps:
    - name: 检出工作流仓库
      uses: actions/checkout@v4

    - name: 记录开始时间
      run: |
        echo "RUN_STARTED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

    - name: 安装 Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: 安装 Rust
      uses: dtolnay/rust-toolchain@stable

    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        distribution: temurin
        java-version: '11'

    - name: Set up Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version: '3.35.7'
        cache: true

    - name: 初始化工作环境
      run: |
        set -euo pipefail

        if [[ "$OSTYPE" == "linux-gnu"* ]]; then
          sudo apt-get -qq update 2>/dev/null || true
          sudo apt-get -qq install -y jq zip >/dev/null 2>&1 || true
        elif [[ "$OSTYPE" == "darwin"* ]]; then
          command -v jq &>/dev/null || brew install jq >/dev/null 2>&1 || true
          command -v zip &>/dev/null || brew install zip >/dev/null 2>&1 || true
        elif [[ "$OSTYPE" == "msys" || "$OSTYPE" == "cygwin" || "$OSTYPE" == "win32" ]]; then
          command -v jq &>/dev/null || choco install jq -y >/dev/null 2>&1 || true
        fi

        bun add crypto-js child_process

    - name: 回调（开始 running）
      if: ${{ inputs.callback_url != '' }}
      env:
        CALLBACK_URL: ${{ inputs.callback_url }}
      run: |
        URL=$(printf '%s' "${CALLBACK_URL}" | tr -d '\r')
        echo "::add-mask::${URL}"
        curl -sS -w "%{http_code}" \
          -H "Content-Type: application/json" \
          -X POST "${URL}" \
          --data '{"status":"running"}' >/dev/null || true

    - name: 克隆目标项目
      shell: bash
      env:
        REPO_OWNER: ${{ inputs.repo_owner }}
        REPO_NAME: ${{ inputs.repo_name }}
        BRANCH: ${{ inputs.branch }}
      run: |
        set -euo pipefail

        [ -n "${GITLAB_URL:-}" ] && echo "::add-mask::${GITLAB_URL}"
        [ -n "${GITLAB_USERNAME:-}" ] && echo "::add-mask::${GITLAB_USERNAME}"
        [ -n "${GITLAB_PASSWORD:-}" ] && echo "::add-mask::${GITLAB_PASSWORD}"

        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"

        GITLAB_BASE="${GITLAB_URL:-https://gitlab.com}"
        GITLAB_USER="${GITLAB_USERNAME:-oauth2}"
        GITLAB_PASS="${GITLAB_PASSWORD:-}"

        GITLAB_HOST="${GITLAB_BASE#https://}"
        if [ -n "${GITLAB_PASS}" ]; then
          REPO_URL="https://${GITLAB_USER}:${GITLAB_PASS}@${GITLAB_HOST}/${REPO_OWNER}/${REPO_NAME}.git"
        else
          REPO_URL="${GITLAB_BASE}/${REPO_OWNER}/${REPO_NAME}.git"
        fi

        git clone -q --branch "${BRANCH}" "${REPO_URL}" target-project

    - name: 安装依赖
      working-directory: target-project
      run: bun install

    - name: 配置项目环境
      if: ${{ inputs.env_vars != '' }}
      working-directory: target-project
      shell: bash
      env:
        ENCRYPTED_ENV: ${{ inputs.env_vars }}
      run: |
        set -euo pipefail
        ENV_FILE=".env"
        TMP=$(mktemp)
        # 解密加密的环境变量并存储到临时文件
        bun "$GITHUB_WORKSPACE/.github/workflows/decrypt-env.ts" "${ENCRYPTED_ENV}" "${SALT:-}" "$TMP"

        # 读取解密后的环境变量并设置为环境变量
        while IFS= read -r line || [[ -n "$line" ]]; do
          [[ -z "$line" || "$line" =~ ^# ]] && continue  # 跳过空行和注释
          if [[ "$line" == *=* ]]; then
            k="${line%%=*}"; v="${line#*=}"
            scrub="${v%\"}"; scrub="${scrub#\"}"; scrub="${scrub%\'}"; scrub="${scrub#\'}"
            [[ -n "$scrub" ]] && echo "::add-mask::$scrub"  # 防止输出敏感数据
            printf '%s=%s\n' "$k" "$v" >> "$GITHUB_ENV"  # 设置环境变量
          fi
        done < "$TMP"

        cp "$TMP" "$ENV_FILE"  # 将解密的环境变量存到 .env 文件
        rm -f "$TMP"  # 删除临时文件

    - name: 执行命令
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail
        BASE=$(pwd)
        CMDS=$(printf '%s' "${{ inputs.commands }}" | tr -d '\r')
        IFS=';' read -ra ARR <<< "$CMDS"
        for cmd in "${ARR[@]}"; do
          cmd="$(echo "$cmd" | xargs)"; [ -z "$cmd" ] && continue
          cd "$BASE" && bun "$GITHUB_WORKSPACE/.github/workflows/run_interactive_command.ts" "$cmd" "$BASE"
        done

    - name: 打包产物
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail
        TS=$(date +"%Y%m%d-%H%M%S")
        ZIP_FILE="build-${TS}.zip"

        RAW=$(printf '%s' "${{ inputs.output_paths }}" | tr -d '\r')
        IFS=';' read -ra PATHS <<< "$RAW"

        for p in "${PATHS[@]}"; do
          # 启用 glob 展开
          shopt -s nullglob
          expanded=($p)
          shopt -u nullglob

          # 如果没有匹配项，使用原路径
          if [ ${#expanded[@]} -eq 0 ]; then
            expanded=("$p")
          fi

          for item in "${expanded[@]}"; do
            if [ -d "$item" ]; then
              (cd "$(dirname "$item")" && zip -r "$OLDPWD/$ZIP_FILE" "$(basename "$item")" >/dev/null)
            elif [ -f "$item" ]; then
              zip -j "$ZIP_FILE" "$item" >/dev/null
            fi
          done
        done

        echo "ZIP_FILE=$ZIP_FILE" >> "$GITHUB_ENV"

    - name: 上传到 R2（Worker 代理）
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail

        RESPONSE=$(curl -sS -X POST "${WORKER_API_URL}/upload" \
          -F "file=@${ZIP_FILE}")

        KEY=$(echo "$RESPONSE" | jq -r '.key')
        [ -z "$KEY" ] || [ "$KEY" = "null" ] && exit 1

        echo "ARTIFACT_KEY=$KEY" >> "$GITHUB_ENV"

    - name: 回调（finished）
      if: ${{ always() && inputs.callback_url != '' }}
      shell: bash
      env:
        CALLBACK_URL: ${{ inputs.callback_url }}
        OWNER: ${{ github.repository_owner }}
        REPO: ${{ github.event.repository.name }}
        RUN_ID: ${{ github.run_id }}
      run: |
        set -euo pipefail

        case "${{ job.status }}" in
          success) STATUS="success" ;;
          failure) STATUS="failed" ;;
          cancelled) STATUS="cancelled" ;;
        esac

        RUN_URL="https://github.com/${OWNER}/${REPO}/actions/runs/${RUN_ID}"

        DOWNLOAD_URL=""
        ARCHIVE_URL=""
        ARTIFACT_SIZE=0

        if [ -n "${ARTIFACT_KEY:-}" ]; then
          DOWNLOAD_URL="${WORKER_API_URL}/download?key=${ARTIFACT_KEY}"
          ARCHIVE_URL="$DOWNLOAD_URL"
          ARTIFACT_SIZE=$(stat -c%s "target-project/${ZIP_FILE}" 2>/dev/null || stat -f%z "target-project/${ZIP_FILE}")
        fi

        artifacts=$(jq -n \
          --arg id "0" \
          --arg name "${ZIP_FILE:-}" \
          --arg size "$ARTIFACT_SIZE" \
          --arg arch "$ARCHIVE_URL" \
          --arg down "$DOWNLOAD_URL" \
          '[{
            id: ($id|tonumber),
            name: $name,
            size_in_bytes: ($size|tonumber),
            archive_url: $arch,
            download_url: $down
          }]')

        payload=$(jq -n \
          --arg status "$STATUS" \
          --arg run_url "$RUN_URL" \
          --argjson artifacts "$artifacts" \
          '{
            status: $status,
            github_run_url: $run_url,
            artifacts: $artifacts
          }')

        curl -sS -H "Content-Type: application/json" \
          -X POST "$CALLBACK_URL" \
          --data "$payload" >/dev/null || true
